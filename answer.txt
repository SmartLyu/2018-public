进行安全配置的思路
    1. 非技术手段： 管理制度(核实设备安全、网络物理连接)   (社会工程学)
    2. 技术手段： 系统安全(权限限定)   服务安全(优化，高可用)   数据安全(备份)   网络安全(加密)

/etc/passwd	用户信息
/etc/shadow	用户密码数据(加密过)
/etc/group	组信息
/etc/gshadow	组密码
/etc/skel/*	添加用户初始环境配置文件，有不少隐藏文件
	这文件夹下的所有文件，再创建用户后，其加目录下就有什么
/etc/profile/	系统配置文件，定义环境变量等信息
/etc/login.defs	添加用户时候如果没有指定信息的时候，设定的默认参数
/etc/issue	决定用户登陆纯字符界面的时侯，会出现什么样子的介绍页面


用户安全

    相关信息的设定命令
useradd	添加用户
userdel	删除用户 (如果使用量参数-r，那么就删除用户的同时删除家目录)
usermod	修改用户信息(-G修改所属组)

chage -l 用户	查看用户的设置信息(用chage设定的信息)
chage -d 天数 用户	设置用户自命令开始计算，多久时间内要修改好密码，不然不能进行任何操作
	如果天数为0，那么用户一旦登陆，必须立刻设置密码
chage -E yyyy-mm-dd 用户	设置用户失效日期，时间到了，用户就会被锁定
	如果年月日那里写成 -1 那么就是永久保留
chage -m 天数 用户	在密码更改之间的最小天数设置，默认天数为 0
	天数为 0 时，表示用户可以在任何时间更改其密码。

passwd 用户	设置密码(--stdin代表非交互设置密码)
passwd -l 用户	锁定用户，锁定后用户不能登陆，在/etc/shadow文件中的密码项前会多处两个叹号作为标识
	这会导致用户将无法通过密码进行登陆，相当于让密码暂时失效，不过密钥还是可以进行登陆等操作
passwd -u 用户	解锁用户
passwd -S 用户	查看用户密码相关信息，第二列是LK是用户被锁定了，如果是PS那就是非锁定
passwd -d 用户	删除用户密码(删除后，用户将无法被远程登陆)


登陆后被强制设定密码的注意点：
     1. 密码必须符合复杂性要求
     2. 密码不能包含用户名
     3. 密码错误超过3次，会弹出
     4. 密码设定成功后，也会弹出，再次登陆就是使用新密码了


特例：
   如果root用户，被锁定了，这时候就没办法登陆root了，而只有root可以解锁，这就成了一个死循环，root被锁不能登陆，而想解锁必须先登陆root，解决方案如下：
     首先，我们在做锁操作前必须思考再三，而且锁后也要确认一下，因为锁用户不会强制下线，所以操作要谨慎
     再之，如果已经出现问题了，那就看看能不能通过密钥登陆，如果可以，那就可以补救
     或者，就看也没有某个用户之前赋予了以root身份使用passwd *的权限，通过其实现
     最后，前面的办法都没用，就重启机器，然后进入抢救模式，和破解root密码差不多的操作，然后解锁root，问题解决


文件系统安全

   锁定文件

   对EXT3/EXT4文件属性控制
chattr  +-=属性              # 修改
lsattr                   # 查看文件属性
控制
+	在原来的的文件属性上添加一个属性，原来属性不变
-	在原来的的文件属性上删除一个属性，如果没有，该操作无意义，不过不报错
=	清空原来文件中所有属性，把=后面的属性加入
	如果=后面为空，其作用就是清空文件属性
属性
	空代表没有特殊控制
i	不可变，不能进行任意的写操作，不能mv、rm等
a	仅仅可以追加，只能用 >> 进行重定向追加操作
c	文件在磁盘上由内核自动进行压缩处理

   注意： 当一个文件属性中有i和a两个属性的时候，将只有i的作用，a的权限将被忽略

[root@client50 ~]# chattr =a /mnt/test.txt 
[root@client50 ~]# lsattr /mnt/test.txt
-----a---------- /mnt/test.txt
[root@client50 ~]# echo 1> /mnt/test.txt
-bash: /mnt/test.txt: 不允许的操作
[root@client50 ~]# echo 1>> /mnt/test.txt
[root@client50 ~]# chattr +i /mnt/test.txt 
[root@client50 ~]# lsattr /mnt/test.txt
----ia---------- /mnt/test.txt
[root@client50 ~]# echo 1>> /mnt/test.txt
-bash: /mnt/test.txt: 权限不够
[root@client50 ~]# chattr = /mnt/test.txt
[root@client50 ~]# lsattr  /mnt/test.txt
---------------- /mnt/test.txt

控制服务
RHEL6	RHEL7	作用
service 服务 start	systemctl start 服务	开启服务
service 服务 stop	systemctl stop 服务	停止服务
chkconfig 服务 on	systemctl enable 服务	开机自动启动服务
chkconfig 服务 off	systemctl disable 服务	不开机自动启动服务







登陆安全

whoami	查看当前用户
su 用户	切换用户，当前所在目录不变，shell环境不变($PATH等)
su - 用户	切换用户，并且当前所在目录切换到用户的家目录，以及shell环境
su - 用户 -c "命令"	不切换用户，只是切换用户的shell环境，执行命令，然后返回命令返回值
tail -f /var/log/secure	动态监听用户相关的所有操作

    很多时候，告知他人某个用户密码会使其拥有用户的所有权，尤其是root，但是有的时候我们又需要把root部分权限分享给某写用户，这时候，就涉及到提权操作
    提权操作，全程提升权限执行操作，也就是root根据需求对个别用户赋予提权操作的权限，之后用户就可以以指定用户的权限执行某些操作
    举个例子，加入root赋予用户user2可以以用户user的身份执行 vim /home/user/* ， 那就意味着，user2可以在登陆自己的账户。然后修改原来自己不能进入的/home/user/目录下所有文件。

which 命令	查找到命令的绝对路径
visudo	管理员配置提权的命令
vim /etc/sudoers
sudu -u 用户 命令	根据管理员设定的提权信息，以命令中-u后面用户的身份运行后面的命令
	不写 -u 用户 则 等效于 -u root，也就说不指定用户，默认以root身份
	所有操作都要注意必须是管理员设置量提权的才可以
sudo -l	列出当前用户所有可以使用的提权操作

   设置提权其实就是修改配置文件，而且修改后立刻生效

/etc/sudoers的详解

# 可以设置别名
Host_Alias 设置主机的别名 = 主机名1, 主机名2
User_Alias 设置用户、组的别名 = 用户1, 用户2 ,%组1 ……
Cmnd_Alias 设置命令的别名 = (用户1)命令1, (用户2)命令2

用户别名  主机别名=命令别名

# 在配置文件中有注释，写了一部分命令的别名，比如，下面就是软件包操作的命令集合的别名
## Installation and management of software
# Cmnd_Alias SOFTWARE = /bin/rpm, /usr/bin/up2date, /usr/bin/yum

## Allow root to run any commands anywhere 
root    ALL=(ALL)       ALL
提权的用户名     localhost,主机名=(用户)命令的绝对路径 相关参数 ,(用户)命令的绝对路径 相关参数

# 每行行首 如果由%开头代表后面操作的是一个组，不过必须先注释wheel那行，因为赋予一个组root全部权限很不安全
## Allows people in group wheel to run all commands
# %wheel ALL=(ALL)       ALL
%提权用户组        localhost,主机名=(用户)命令的绝对路径 相关参数 ,(用户)命令的绝对路径 相关参数

# 开启日志记录功能，所有用户用sudo进行提权操作都会记录下来
Defaults logfile="/var/log/sudo"

注意：
    1. 使用的时候可以不写绝对路径，但是配置的时候必须是命令的绝对路径
    2. 配置文件中，相关参数可以用*，来做通配任意多个任意字符
    3. 如果想用多个组，设置User别名，只需要在每个具体组名前加上一个%即可






ssh
    控制其他机器远程访问本机器，提高安全性
修改配置文件/etc/ssh/sshd_config
配置信息	功能解释
Port 端口	设置ssh监听的端口，修改成非22端口，别的机器远程，就要 ssh -p 端口 IP 才可以登陆量
	默认是注释了的，因为没有指定的时候是22端口
ListenAddress 其他服务器IP列表	设置允许远程访问来的的机器的IP列表
	默认也是注释的，没有定义的时候，默认允许所有的IP远成分访问
PermitRootLogin yes	是否允许root远程登陆，如果是no就是不允许
	默认被注释量，没有定义的时候，默认是yes，也就是允许root远程登陆
LoginGraceTime 2m	登陆限制时间，也就是用户输入密码等待时间太久，服务器会断开
	这样不管密码对不对输入密码超时都会拒绝连接
MaxAuthTries 6	设定最大密码验证次数
	不过当设定值超过3的时候，也值能输入错误3次，否则报错
AllowUsers 用户1@登陆使用的主机IP 用户1	设置白名单，只有通过指定的指定的主机登陆对应的用户才能登陆成功
	如果没有@ ，默认是允许所有的主机登陆该用户访问
AllowGroups 组名1 组名2	设置组内所有成员的一个白名单	
DenyUsers 用户1@登陆使用的主机IP 用户1	设置黑名单，只要用户不以指定的主机登陆指定用户就可以正常登陆
	如果没有@ ，默认是不允许所有的主机登陆该用户访问
DenyGroups 组名1 组名2	设置组内所有成员的一个黑名单	

PasswordAuthentication yes	指定能否用密码登陆，默认是yes，也就是允许的
	如果改为no，那么远程访问值能通过密钥进行连接


特例：
    1. 当AllowUsers和DenyUsers同时存在，不管哪个在前哪个在后，都是只要Deny明确拒绝了某个用户，这个用户就不能登陆，而AllowUsers列表以外的用户也是不能登陆的
    2. 当一个用户属于一个组，这个组设置允许登陆，用户设置不能登陆，结果这个用户是不能登陆，这个用户设置允许登陆，组设置不能登陆，结果这个用户是不能登陆，总结下来对于一个用户，不管其对其所属组还是直接对用户，Deny会覆盖Allow的设置

    举例：假设当前有3个用户：tes1、test2、test3； test1和test2属于组test，test3没有所属组

配置文件中的内容	test1能否登陆	test2能否登陆	test3能否登陆
AllowUsers test1	能	不能	不能
AllowGroups test	能	能	不能
AllowUsers test3	能	能	能
AllowGroups test

DenyUsers test1	不能	能	能
DenyGroups test	不能	不能	能
DenyUsers test3	不能	不能	不能
DenyGroups test

AllowUsers test1 test2	不能	能	不能
DenyUsers test1
AllowGroups test	不能	能	不能
DenyUsers test1
AllowUsers test1 test2	不能	不能	不能
DenyGroup test
AllowUsers test1 test3	不能	不能	能
DenyGroup test

密钥验证









