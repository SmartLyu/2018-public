主从同步

    原理：从库向主库发送同步请求(sync)，接收到后启动一个程序进行后台存储，然后把保存的rdb文件发给从库，然后从库读取文件实现同步，之后主库每进行一次写操作就会启动一个程序，把修改命令发给从库，实现实时同步

    配置：
       所有库都默认拥有主库的配置，所以配置主从只需要从库进行配置即可
       查看当前状态(role:后面写的就是主库或者从库    master_link_status:代表连接状态)
info replication
       从库配置
slaveof 主库IP 端口
# 如果主库设置量登陆密码，那就需要指定密码
config set masterauth 密码
       取消从库
slaveof no one

       永久设置(修改配置文件)
sed -i '/slaveof </cslaveof 192.168.4.51 6351' /etc/redis/6379.conf 
# 如果主库设置了登陆密码
sed -i '/masterauth/cmasterauth 密码' /etc/redis/6379.conf 

    优点： 主从同步可以对数据进行备份，是负载均衡高可用的基础服务

    缺点： 当网络繁忙或者系统繁忙的时候，数据同步有延时

    安全检测(高可用)：
       哨兵模式，用于检测主库健康性的系统，当发现主库出现问题，立刻让一个从库成为主库，继续服务
       搭建过程： 装包、配置、启服务
          装包： 安装redis软件中就有
          配置： 编写配置文件，可以放在任意位置，只要自己清楚即可
sentinel monitor 自定义的哨兵名  监听的主库IP号 主库端口号 票数
sentinel auth-pass 哨兵名 登陆主库的密码(没有密码的话不要这一行)
          解释：
              1. 票数 ， 这指的是，多个哨兵的时候，当有几个哨兵服务器发现服务器有问题，就切换主库，如果值有一个哨兵，那就只能写1了
              2. 哨兵切换主库后，也会自动修改这个配置文件，并继续监听
              3. 票数设置方面，满足两个条件最佳，票数尽量不要为一、票数不要和哨兵服务器一样
                  如果有多个服务器，最好是 票数 = 哨兵服务器数 - 1，防止某个哨兵出现为题
          启动服务: 
redis-sentinel  编写的配置文件位置


数据备份—RDB/AOF

RDB
    简介，全称 Redis DataBase 是redis数据库默认启动的备份方式，其工作原理和快照，按照一定时间间隔或者指定命令，把内存中的数据全部存入磁盘中
    配置：在配置文件 /etc/redis/6379.conf 中，默认开启，其中行首为save的配置都是相关项
save ""	# 禁用RBD，默认被注释了
save 900 1	# 每隔900s的时间内，并且有1隔数据就该就进行备份
save 300 10	# 每隔300s的时间内，并且有10隔数据就该就进行备份
save 60 10000	# 每隔60s的时间内，并且有10000隔数据就该就进行备份
dbfilename "dump.rdb"	# 指定存储文件名为dump.rdb，可以修改
rdbcompression yes	# 是否开启压缩
rdbchecksum yes		# 存储快照后进行一次数据校验
stop-writes-on-bgsave-error yes	# 当bgsave出错的时候停止写操作

   具体解释： 主要解释save，配置文件中有多行关于save时间间隔的配置，其主要用法是，从开启服务开始，每隔指定秒数，检查这端时间内也没有达到指定的修改文件的个数，如果够了就备份，如果没够就重新计时和计数，举例就是，save 60 10000，每隔60s查看一些这1分钟内也没有达到10000个修改，如果够了那就备份然后重新计时，如果没够就重新然后重新计时，并且清空之前的计数

   手动存盘：
      save 指存盘时候不能写操作
      bgsave 指存盘的时候可以同时进行写操作

   优点： 适合大规模数据的时候备份恢复，
   缺点： 意外down机的时候丢失数据较多

AOF

   简介，全称 Append Only File 只做追加操作，记录redis的全部写操作，不断把写操作追加到文件末尾

   开启aof的操作：
# 修改配置文件中如下内容，把no改为yes
appendonly no
appendfilename "appendonly.aof"

# 命令执行结果如下
sed -i '/appendonly /cappendonly yes' /etc/redis/6379.conf 

   设定AOF文件记录写操作的频率：
appendfsync always	# 指代每有一个写操作就将其记录到内存(极其占用资源)
appendfsync everysec	# 指代每秒钟记录一次(默认的记录频率)
appendfsync no		# 指代当系统每隔一段时间将内存写入磁盘的时候，写入磁盘(极高丢失率)

   修复AOF： 在命令行中执行修复命令
redis-check-aof --fix AOF文件

   优点： 在意外down机的时候丢失数据很少，最多只有1秒的数据

   缺点： 存储文件往往很大，而且备份速度慢

两种数据备份：
    1. 进行数据的备份存储都是保存一个文件在/var/lib/redis/6379/下，文件名都是配置文件中自定义的
    2. 如果需要备份到其他地方，把存储文件复制保存即可，恢复的时候，把备份的文件拷贝到指定位置，并命名为指定的文件名即可
    3. 在两个备份都开启的时候，启动数据库，默认读取AOF备份文件










数据类型

String字符串类型

    默认所有设置的数据都是String类型
    要注意这下面命令中，所有位置都是从0开始计数，而负数代表从后往前数，-1代表最后一个
    下面所有用的例子中的 example 变量值为123456

创建或修改一个String类型的变量set 变量 值 [ex 秒 px毫秒 nx|xx]
	参数ex是定义变量的有效时间，单位是秒
	参数px是定义变量的有效时间，单位是毫秒
	参数nx指，该set命令只能进行创建，如果命令中变量存在，命令就会报错
	参数xx指，该set命令只能进行修改，如果命令中变量不存在，命令就会报错
修改某字符串的部分字符	setrange  变量 从第几位开始 替换成的字符
	setrange example 3 **   --> example值为 123**6
统计字符长度	strlen 变量
追加写入	append 变量 值
	append exmaple 789  -->  example值为 123456789
计数存储数据	setbit 变量 位置 值
	这是特殊的一个计数方式，位置是0-2^32内的数字，一般是从小到大依次存储
	值只能是0或者1
	命令的意思就是，变量按照一个位置一个值，最后把变量中所有位置中值为1的个数计算出来，达到计数的目的
计数存储读取	bitcount变量
从变量中的指定位置截取字段	getrange 变量 开始位置 结束位置
	getrange example 0 -1  -->  返回值 123456
	getrange example 2 3  -->  返回值 3
	getrange example 1 7  -->  返回值 23456
	getrange example 7 1  -->  返回值为空 ""
同时存储多个值	mset 变量1 值1 变量2 值2 变量3 值3
同时读取多个值	mget 变量1 变量2 变量3
变量值自减一	decr 变量
	如果变量中值有数字，那可以进行自减一的操作，有一个非数字字符都不能进行加减运算
变量值减去指定数值	decrby 变量 减少的值
变量值自加一	incr 变量
变量值加上指定数值	incrby 变量 减少的值
变量值加上一个小数	incrbyfloat 变量 小数
	注意，不能减少某个小数，命令不支持


list列表存储
    
      存储算法是堆栈，其存数据的读取是先进后出

创建一个列表	lpush 列表名 值1 值2 值3
	存进去后，值3是第一个值，值1是最后一个值
读取一个列别	lrange 列表名 开始位置 终止位置
输出并删除表头数据	lpop 列表
	表头数据就是读取的第一个数据，也就是最后一个存进去的数据
统计列表中值的个数	llen 列表
输出列表中指定位置的值	lindex 列表 位置
	lindex 列表 0   输出列表中的第一个值，和lpop不同，这只输出，不删除
	lindex 列表 -1   输出列表中的最后一个值
修改指定位置的只	lset 列表 位置 值
	lset 列表 0 123 把表的第一个值修改为123
把指定值插入到最后一个后面	rpush 列表 值1 值2
	lpush example 1 2 3 4
	lrange example 0 -1  --> 返回值为 4 3 2 1
	rpush example 5 6
	lrange example 0 -1  --> 返回值为 4 3 2 1 5 6
输出并删除最后的值	rpush 列表





